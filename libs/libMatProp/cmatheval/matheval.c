/*
 * Copyright (C) 1999, 2002, 2003, 2004, 2005, 2006, 2007 Free Software
 * Foundation, Inc.
 *
 * This file is part of GNU libmatheval
 *
 * GNU libmatheval is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by the Free
 * Software Foundation; either version 2, or (at your option) any later
 * version.
 *
 * GNU libmatheval is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
 * for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * program; see the file COPYING. If not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */

#include <ctype.h>

#if HAVE_CONFIG_H
#include "config.h"
#endif

#include "common.h"
#include "cmatheval.h"
#include "node.h"
#include "symbol_table.h"

/* Minimal length of cevaluator symbol table.  */
#define MIN_TABLE_LENGTH 211

/* Function used to parse string representing function (this function is
 * generated by parser generator). */
extern int      yyparse();

/* Following variables are needed for parsing (parser is able to
 * communicate with program from which it is used through global variables
 * only). */
char           *input_string;	/* String representing function.  */
Node           *root;		/* Root of tree representation of
				 * function.  */
SymbolTable    *symbol_table;	/* Evaluator symbol table.  */
int             ok;		/* Flag determining if parsing went OK.  */

/* Data structure representing cevaluator.  */
typedef struct {
	Node           *root;	/* Root of tree representation of
				 * function.  */
	SymbolTable    *symbol_table;	/* Evalutor symbol table.  */
	char           *string;	/* Evaluator textual representation. */
	int             count;	/* Number of cevaluator variables. */
	char          **names;	/* Array of pointers to cevaluator variable
				 * names. */
} Evaluator;

void           *
cevaluator_create(char *string)
{
	Evaluator      *cevaluator;	/* Evaluator representing function
					 * given by string.  */
	char           *stringn;	/* Copy of string terminated by
					 * newline character.  */

	/* Copy string representing function and terminate it with newline
	 * (this is necessary because parser expect newline character to
	 * terminate its input). */
	stringn = XMALLOC(char, strlen(string) + 2);

	strcpy(stringn, string);
	strcat(stringn, "\n");

	/* Initialize global variables used by parser. */
	input_string = stringn;
	root = NULL;
	symbol_table = symbol_table_create(MIN_TABLE_LENGTH);
	ok = 1;

	/* Do parsing. */
	yyparse();

	/* Free copy of string representing function. */
	XFREE(stringn);

	/* Return null pointer as error indicator if parsing error
	 * occured. */
	if (!ok)
		return NULL;

	/* Simplify tree represention of function. */
	root = node_simplify(root, 0);

	/* Allocate memory for and initialize cevaluator data structure. */
	cevaluator = XMALLOC(Evaluator, 1);
	cevaluator->root = root;
	cevaluator->symbol_table = symbol_table;
	cevaluator->string = NULL;
	cevaluator->count = 0;
	cevaluator->names = NULL;

	return cevaluator;
}

void
cevaluator_destroy(void *cevaluator)
{
	/* Destroy tree represention of function, symbol table, array of
	 * pointers to cevaluator variable names, as well as data structure
	 * representing cevaluator. */
	node_destroy(((Evaluator *) cevaluator)->root);
	symbol_table_destroy(((Evaluator *) cevaluator)->symbol_table);
	XFREE(((Evaluator *) cevaluator)->string);
	XFREE(((Evaluator *) cevaluator)->names);
	XFREE(cevaluator);
}

int cevaluator_set_var(void *cevaluator, const char *name, cmplx val)
{
     Record *record = symbol_table_lookup(((Evaluator *) cevaluator)->
					  symbol_table, name);
     if (record && record->type == 'v') {
	  record->data.value = val;
	  return 1; /* success */
     }
     return 0; /* failure */
}

cmplx cevaluator_get_var(void *cevaluator, const char *name)
{
     Record *record = symbol_table_lookup(((Evaluator *) cevaluator)->
					  symbol_table, name);
     if (record && record->type == 'v')
	  return record->data.value;
     return 0.0; /* unknown variable */
}

/* Set a variable in the symbol table to use a fixed index into the "values"
   array passed to cevaluator_evaluate.  This makes changing the variable
   thread-safe (since the symbol table is no longer modified when the variable
   is set), but means that the user has to be careful to be consistent about
   the values array. */
int cevaluator_set_var_index(void *cevaluator, const char *name, ptrdiff_t idx)
{
     Record *record = symbol_table_lookup(((Evaluator *) cevaluator)->
					  symbol_table, name);
     if (record && tolower(record->type) == 'v') {
	  record->type = 'V'; /* thread-safe variable */
	  record->data.index = idx;
	  return 1; /* success */
     }
     return 0; /* failure */
}

cmplx
cevaluator_evaluate(void *cevaluator, int count, char **names,
		   cmplx *values)
{
	Record         *record;	/* Symbol table record corresponding to
				 * given variable name.  */
	int             i;	/* Loop counter.  */

	/* Assign values to symbol table records corresponding to variable
	 * names. */
	for (i = 0; i < count; i++) {
		record =
		    symbol_table_lookup(((Evaluator *) cevaluator)->
					symbol_table, names[i]);
		if (record && record->type == 'v')
			record->data.value = values[i];
	}

	/* Evaluate function value using tree represention of function. */
	return node_evaluate(((Evaluator *) cevaluator)->root, values);
}

int
cevaluator_is_real(void *cevaluator, int count, char **names,
		   cmplx *values)
{
	Record         *record;	/* Symbol table record corresponding to
				 * given variable name.  */
	int             i;	/* Loop counter.  */
	Node *copy;

	/* Assign values to symbol table records corresponding to variable
	 * names. */
	for (i = 0; i < count; i++) {
		record =
		    symbol_table_lookup(((Evaluator *) cevaluator)->
					symbol_table, names[i]);
		if (record && record->type == 'v')
			record->data.value = values[i];
	}

	copy = node_copy(((Evaluator *) cevaluator)->root);
	copy = node_simplify(copy, 1); /* simplify including constants */
	i = node_is_real(copy, values);
	node_destroy(copy);
	return i;
}

char           *
cevaluator_get_string(void *cevaluator)
{
	int             length;	/* Length of cevaluator textual
				 * representaion. */

	/* If not already, create and remember cevaluator textual
	 * representation. */
	if (!((Evaluator *) cevaluator)->string) {
		length = node_get_length(((Evaluator *) cevaluator)->root);
		((Evaluator *) cevaluator)->string =
		    XMALLOC(char, length + 1);
		node_write(((Evaluator *) cevaluator)->root,
			   ((Evaluator *) cevaluator)->string);
		((Evaluator *) cevaluator)->string[length] = 0;
	}

	/* Return requsted information. */
	return ((Evaluator *) cevaluator)->string;
}

void
cevaluator_get_variables(void *cevaluator, char ***names, int *count)
{
	Record        **records;	/* Array of symbol table records
					 * containing cevaluator variables.
					 */
	int             i;	/* Loop counter.  */

	/* If not already, find and remember cevaluator variable names. */
	if (!((Evaluator *) cevaluator)->names) {
		symbol_table_clear_flags(((Evaluator *) cevaluator)->
					 symbol_table);
		node_flag_variables(((Evaluator *) cevaluator)->root);
		((Evaluator *) cevaluator)->count =
		    symbol_table_get_flagged_count(((Evaluator *)
						    cevaluator)->
						   symbol_table);
		records =
		    XMALLOC(Record *, ((Evaluator *) cevaluator)->count);
		symbol_table_get_flagged(((Evaluator *) cevaluator)->
					 symbol_table, records,
					 ((Evaluator *) cevaluator)->count);
		((Evaluator *) cevaluator)->names =
		    XMALLOC(char *, ((Evaluator *) cevaluator)->count);
		for (i = 0; i < ((Evaluator *) cevaluator)->count; i++)
			((Evaluator *) cevaluator)->names[i] =
			    records[i]->name;
		XFREE(records);
	}

	/* Return requested information. */
	*count = ((Evaluator *) cevaluator)->count;
	*names = ((Evaluator *) cevaluator)->names;
}

void           *
cevaluator_derivative(void *cevaluator, const char *name)
{
	Evaluator      *derivative;	/* Derivative function cevaluator. */

	/* Allocate memory for and initalize data structure for cevaluator
	 * representing derivative of function given by cevaluator. */
	derivative = XMALLOC(Evaluator, 1);
	derivative->root =
	    node_simplify(node_derivative
			  (((Evaluator *) cevaluator)->root, name,
			   ((Evaluator *) cevaluator)->symbol_table), 0);
	derivative->symbol_table =
	    symbol_table_assign(((Evaluator *) cevaluator)->symbol_table);
	derivative->string = NULL;
	derivative->count = 0;
	derivative->names = NULL;

	return derivative;
}

cmplx
cevaluator_evaluate_x(void *cevaluator, cmplx x)
{
	char           *names[] = {
		"x"
	};			/* Array of variable names.  */
	cmplx          values[1];	/* Array of variable values.  */

	/* Evaluate function for given values of variable "x". */
	values[0] = x;
	return cevaluator_evaluate(cevaluator,
				  sizeof(names) / sizeof(names[0]), names,
				  values);
}

cmplx
cevaluator_evaluate_x_y(void *cevaluator, cmplx x, cmplx y)
{
	char           *names[] = {
		"x", "y"
	};			/* Array of variable names.  */
	cmplx          values[2];	/* Array of variable values.  */

	/* Evaluate function for given values of variable "x" and "y". */
	values[0] = x, values[1] = y;
	return cevaluator_evaluate(cevaluator,
				  sizeof(names) / sizeof(names[0]), names,
				  values);
}

cmplx
cevaluator_evaluate_x_y_z(void *cevaluator, cmplx x, cmplx y, cmplx z)
{
	char           *names[] = {
		"x", "y", "z"
	};			/* Array of variable names.  */
	cmplx          values[3];	/* Array of variable values.  */

	/* Evaluate function for given values of variable "x", "y" and
	 * "z". */
	values[0] = x, values[1] = y, values[2] = z;
	return cevaluator_evaluate(cevaluator,
				  sizeof(names) / sizeof(names[0]), names,
				  values);
}

void           *
cevaluator_derivative_x(void *cevaluator)
{
	/* Differentiate function using derivation variable "x". */
	return cevaluator_derivative(cevaluator, "x");
}

void           *
cevaluator_derivative_y(void *cevaluator)
{
	/* Differentiate function using derivation variable "y". */
	return cevaluator_derivative(cevaluator, "y");
}

void           *
cevaluator_derivative_z(void *cevaluator)
{
	/* Differentiate function using derivation variable "z". */
	return cevaluator_derivative(cevaluator, "z");
}
